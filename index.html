<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <title>Neon Bros</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Orbitron', 'Microsoft YaHei', sans-serif; user-select: none; }
        canvas { display: block; }
        
        .btn {
            display: inline-flex; justify-content: center; align-items: center;
            width: 28px; height: 28px; border-radius: 50%; 
            margin: 0 5px; position: relative; vertical-align: middle;
            box-shadow: 0 3px 0 rgba(0,0,0,0.5); font-family: Arial, sans-serif; font-weight: bold;
        }
        .xbox-a { background: #1a1a1a; color: greenyellow; border: 2px solid #414040; font-size: 16px; }
        .xbox-x { background: #1a1a1a; color: rgb(27, 109, 216); border: 2px solid #414040; font-size: 16px; }

        .ps-cross { background: #1a1a1a; border: 2px solid #414040; }
        .ps-cross::after { content: '✕'; color: #4f9ee7; font-size: 16px; font-weight: bold; }
        .ps-square { background: #1a1a1a; border: 2px solid #414040; }
        .ps-square::after { content: ''; display: block; width: 10px; height: 10px; border: 3px solid #d856ac; border-radius: 2px; }
        
        .bumper-icon {
            display: inline-block; padding: 2px 8px; background: #333; 
            border: 1px solid #666; border-radius: 4px; color: #fff; 
            font-size: 10px; font-weight: bold; margin: 0 5px;
        }

        .sys-btn {
            display: inline-flex; align-items: center; justify-content: center;
            padding: 4px 12px;
            background: linear-gradient(180deg, #3d3d3d, #1a1a1a);
            border: 1px solid #555;
            border-bottom: 3px solid #000;
            border-radius: 20px;
            color: #eee;
            font-family: Arial, sans-serif;
            font-size: 11px;
            font-weight: bold;
            letter-spacing: 1px;
            margin: 0 6px;
            box-shadow: 0 5px 10px rgba(0,0,0,0.5);
            text-shadow: 0 -1px 0 black;
        }
        
        .xbox-menu::before { content: '☰'; font-size: 14px; margin-right: 5px; color: #ccc; }
        .ps-opt { min-width: 60px; }
        .ps-opt::before { content: 'OPTIONS'; }

        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        .top-bar { display: flex; justify-content: space-between; padding: 20px 50px; text-shadow: 0 0 10px currentColor; font-size: 24px; font-weight: bold; }
        #p1-score { color: #00f7ff; }
        #p2-score { color: #ffaa00; }

        #wave-hud { position: absolute; top: 80px; width: 100%; text-align: center; color: white; text-shadow: 0 0 15px rgba(255,255,255,0.5); transition: 0.3s; }
        .wave-title { font-size: 32px; font-weight: 900; letter-spacing: 2px; color: #ff0055; margin-bottom: 5px; }
        .wave-info { font-size: 18px; color: #aaa; }
        .boss-warning { color: #bf00ff !important; text-shadow: 0 0 20px #bf00ff !important; animation: shake 0.5s infinite; }

        @keyframes shake { 0% { transform: translate(1px, 1px) rotate(0deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); } }

        .bottom-bar { display: flex; justify-content: space-between; padding: 20px 50px; align-items: end; }
        .ulti-container { width: 300px; text-align: left; opacity: 0.9; }
        .ulti-label { color: white; font-size: 14px; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
        .ulti-bar-bg { width: 100%; height: 12px; background: #222; border: 2px solid #444; border-radius: 6px; overflow: hidden; }
        .ulti-bar-fill { height: 100%; width: 0%; transition: width 0.1s linear; box-shadow: 0 0 15px currentColor; }
        
        #start-screen, #pause-screen, #gameover-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; z-index: 10; pointer-events: auto;
        }
        #start-screen { background: radial-gradient(circle, rgba(10,10,20,0.98) 0%, #000 100%); }
        #pause-screen { background: rgba(0, 0, 0, 0.85); display: none; z-index: 20; }
        #gameover-screen { background: rgba(0, 0, 0, 0.95); display: none; z-index: 30; }

        h1 { font-size: 70px; margin: 0; letter-spacing: 5px; background: linear-gradient(to right, #00f7ff, #ffffff, #ffaa00); -webkit-background-clip: text; color: transparent; text-shadow: 0 0 30px rgba(255,255,255,0.3); }

        .status-area { margin-top: 50px; display: flex; gap: 40px; }
        .player-card {
            background: rgba(255,255,255,0.05); padding: 20px 40px; border-radius: 10px; border: 1px solid #333;
            text-align: center; width: 200px; transition: 0.3s;
        }
        .player-card.connected { border-color: #555; background: rgba(255,255,255,0.1); }
        .player-card.ready { border-color: #00ff00; background: rgba(0, 255, 0, 0.1); box-shadow: 0 0 20px rgba(0, 255, 0, 0.2); transform: scale(1.05); }

        .con-name { font-size: 12px; color: #888; margin-top: 5px; }
        .start-prompt { margin-top: 15px; font-size: 14px; opacity: 0.5; }
        .ready-text { font-size: 18px; font-weight: bold; color: #00ff00; margin-top: 10px; display: none; }
        .player-card.ready .ready-text { display: block; }
        .player-card.ready .start-prompt { display: none; }

        .score-detail { font-size: 30px; margin-top: 20px; color: #fff; font-weight: bold; }
        .score-sub { font-size: 16px; color: #aaa; margin-top: 5px; }
        .txt-waiting { animation: pulse 1s infinite alternate; }
        @keyframes pulse { from { opacity: 0.5; } to { opacity: 1; } }

        .lang-bar { margin-top: 50px; display: flex; gap: 10px; }
        .lang-btn {
            background: #222; color: #888; border: 1px solid #444; padding: 10px 20px;
            cursor: pointer; font-family: 'Orbitron', sans-serif; font-size: 14px;
            transition: 0.2s; min-width: 80px; text-align: center;
        }
        .lang-btn.active {
            background: #00f7ff; color: #000; border-color: #00f7ff;
            box-shadow: 0 0 15px #00f7ff; font-weight: bold; transform: scale(1.1);
        }

        .menu-options { display: flex; flex-direction: column; gap: 15px; margin-top: 40px; }
        .menu-btn {
            background: transparent; border: 2px solid #555; color: #aaa;
            padding: 15px 40px; font-size: 18px; font-family: 'Orbitron', sans-serif;
            cursor: pointer; transition: 0.2s; text-align: center; width: 200px;
        }
        .menu-btn.selected {
            border-color: #ffaa00; color: #ffaa00; background: rgba(255, 170, 0, 0.1);
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.3); transform: scale(1.05); font-weight: bold;
        }

    </style>
</head>
<body>
    
    <audio id="bg-music" loop>
        <source src="https://files.freemusicarchive.org/storage-freemusicarchive-org/music/ccCommunity/Tours/Enthusiast/Tours_-_01_-_Enthusiast.mp3" type="audio/mpeg">
    </audio>

    <div id="pause-screen">
        <h1 style="font-size: 50px;" id="txt-paused">DURAKLATILDI</h1>
        <div class="menu-options" id="pause-menu">
            <div class="menu-btn selected" id="btn-resume">DEVAM ET</div>
            <div class="menu-btn" id="btn-menu-pause">ANA MENÜ</div>
        </div>
        <div id="txt-nav-hint" style="margin-top: 30px; font-size: 12px; color: #666;">
            (SOL ANALOG: Seç / A: Onayla)
        </div>
    </div>

    <div id="gameover-screen">
        <h1 style="font-size: 60px;" id="txt-gameover">OYUN BİTTİ</h1>
        <div id="total-score-display" class="score-detail">TOPLAM PUAN: 0</div>
        <div id="final-wave-display" class="score-sub">ULAŞILAN DALGA: 1</div>
        
        <div class="menu-options" id="gameover-menu">
            <div class="menu-btn selected" id="btn-restart">YENİDEN BAŞLA</div>
            <div class="menu-btn" id="btn-menu-over">ANA MENÜ</div>
        </div>
    </div>

    <div id="ui">
        <div class="top-bar">
            <span id="p1-score">P1: 0</span>
            <div id="wave-hud">
                <div id="wave-title" class="wave-title">DALGA 1</div>
                <div id="wave-info" class="wave-info">Düşmanlar Geliyor...</div>
            </div>
            <span id="p2-score">P2: 0</span>
        </div>
        
        <div class="bottom-bar">
            <div class="ulti-container">
                <div class="ulti-label">
                    <span id="p1-ulti-icon" class="btn"></span> <span id="txt-ulti-1">Şok Dalgası</span> <span id="p1-ulti-text" style="color:#00f7ff; font-size:10px; margin-left:auto;">HAZIR!</span>
                </div>
                <div class="ulti-bar-bg"><div id="p1-ulti-bar" class="ulti-bar-fill" style="background:#00f7ff; width:100%;"></div></div>
            </div>
            <div class="ulti-container" style="text-align:right;">
                <div class="ulti-label" style="justify-content: flex-end;">
                    <span id="p2-ulti-text" style="color:#ffaa00; font-size:10px; margin-right:auto;">HAZIR!</span> <span id="txt-ulti-2">Şok Dalgası</span> <span id="p2-ulti-icon" class="btn"></span>
                </div>
                <div class="ulti-bar-bg"><div id="p2-ulti-bar" class="ulti-bar-fill" style="background:#ffaa00; width:100%;"></div></div>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <h1>NEON BROS</h1>
        <div style="font-size: 14px; letter-spacing: 5px; color: #666; margin-bottom: 30px;">GEOMETRIC WARFARE EDITION</div>
        
        <div class="status-area">
            <div id="p1-card" class="player-card">
                <div style="font-size:20px; font-weight:bold; color:#00f7ff;" id="txt-p1-title">OYUNCU 1</div>
                <div id="p1-con-name" class="con-name txt-waiting">KOL SEÇİNİZ</div>
                <div id="p1-prompt" class="start-prompt"><span id="p1-start-icon" class="btn" style="border:1px dashed #555; color:#555">?</span> <span class="txt-press-btn">KATIL</span></div>
                <div class="ready-text txt-ready">HAZIR</div>
            </div>
            <div id="p2-card" class="player-card">
                <div style="font-size:20px; font-weight:bold; color:#ffaa00;" id="txt-p2-title">OYUNCU 2</div>
                <div id="p2-con-name" class="con-name txt-waiting">KOL SEÇİNİZ</div>
                <div id="p2-prompt" class="start-prompt"><span id="p2-start-icon" class="btn" style="border:1px dashed #555; color:#555">?</span> <span class="txt-press-btn">KATIL</span></div>
                <div class="ready-text txt-ready">HAZIR</div>
            </div>
        </div>
        <div style="margin-top:30px; font-size:12px; color:#555;" id="txt-start-info">(Her İki Oyuncu Hazır Olduğunda Başlar)</div>

        <div class="lang-bar" id="lang-menu">
            <div class="lang-btn active" data-lang="tr">TÜRKÇE</div>
            <div class="lang-btn" data-lang="en">ENGLISH</div>
            <div class="lang-btn" data-lang="de">DEUTSCH</div>
            <div class="lang-btn" data-lang="zh">中文</div>
        </div>
        <div style="margin-top: 10px; font-size: 10px; color: #444; display: flex; align-items: center; gap: 5px;">
            <span class="bumper-icon">LB</span> / <span class="bumper-icon">RB</span> <span id="txt-lang-hint"> : DİL DEĞİŞTİR</span>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // --- ZAMANLAMA AYARLARI (HIZ SABİTLEME) ---
    // Burası oyunun tüm cihazlarda 90 FPS hızında (PC hızı) hesaplanmasını sağlar.
    const TARGET_FPS = 90; 
    const TIME_STEP = 1000 / TARGET_FPS; 
    let lastTime = 0;
    let accumulator = 0;

    // --- SES MOTORU (SFX) ---
    const AudioEngine = {
        ctx: null,
        masterGain: null,
        initialized: false,
        bgMusicElement: document.getElementById('bg-music'),
        
        init: function() {
            if (this.initialized) return;
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.3; 
            this.masterGain.connect(this.ctx.destination);
            
            this.bgMusicElement.volume = 0.4;
            this.bgMusicElement.play().catch(e => console.log("Müzik başlatılamadı:", e));

            this.initialized = true;
        },

        playTone: function(freq, type, duration, vol=0.5, slideTo=0) {
            if (!this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            if(slideTo > 0) {
                osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + duration);
            }
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            
            // Lowpass filtre
            if (type === 'triangle') {
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                osc.connect(filter);
                filter.connect(gain);
            } else {
                osc.connect(gain);
            }
            
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        },

        playShoot: function() { 
            this.playTone(300, 'triangle', 0.1, 0.1, 50); 
        },

        playExplosion: function() { 
            this.playTone(50, 'sawtooth', 0.3, 0.4); 
            this.playTone(30, 'square', 0.4, 0.4); 
        },
        playMenuMove: function() { this.playTone(400, 'sine', 0.05, 0.2); },
        playMenuSelect: function() { this.playTone(600, 'sine', 0.1, 0.2); },
        
        playUlti: function() { 
            this.playTone(150, 'sawtooth', 1.5, 0.6, 10);
            setTimeout(() => this.playTone(400, 'square', 0.1, 0.3, 800), 100);
            setTimeout(() => this.playTone(800, 'sawtooth', 0.1, 0.2, 200), 250);
            setTimeout(() => this.playTone(60, 'square', 0.5, 0.5), 400); 
        }
    };

    // --- TİTREŞİM YARDIMCISI (DUALSENSE FIX) ---
    function rumble(padIndex, duration, weak, strong) {
        const pads = navigator.getGamepads ? navigator.getGamepads() : [];
        const pad = pads[padIndex];
        
        if (pad && pad.vibrationActuator) {
            pad.vibrationActuator.playEffect("dual-rumble", {
                startDelay: 0,
                duration: duration,
                weakMagnitude: weak,
                strongMagnitude: strong
            }).catch(e => {});
        }
    }

    // --- DİL SİSTEMİ ---
    const translations = {
        tr: { paused: "DURAKLATILDI", resume: "DEVAM ET", menu: "ANA MENÜ", restart: "YENİDEN BAŞLA", gameover: "OYUN BİTTİ", totalScore: "TOPLAM PUAN: ", waveReached: "ULAŞILAN DALGA: ", pressBtn: "BAS", pressJoin: "KATIL", wave: "DALGA", enemiesComing: "Düşmanlar Geliyor...", remaining: "Kalan: ", bossHp: "BOSS CANI: ", nextWave: "SONRAKİ DALGA: ", waveComplete: "DALGA TAMAMLANDI!", bossFight: "BOSS SAVAŞI!", bossMinions: "BOSS + MİNYONLAR!", ulti: "Şok Dalgası", ready: "HAZIR!", readySimple: "HAZIR", p1: "OYUNCU 1", p2: "OYUNCU 2", noController: "KOL SEÇİNİZ", startInfo: "(Her İki Oyuncu Hazır Olduğunda Başlar)", revive: "KURTAR", frozen: "DONDU!", controllerPS: "PS KOLU", controllerXbox: "XBOX KOLU", langHint: " : DİL DEĞİŞTİR", navHint: "(SOL ANALOG: Seç / A: Onayla)" },
        en: { paused: "PAUSED", resume: "RESUME", menu: "MAIN MENU", restart: "RETRY", gameover: "GAME OVER", totalScore: "TOTAL SCORE: ", waveReached: "WAVE REACHED: ", pressBtn: "PRESS", pressJoin: "JOIN", wave: "WAVE", enemiesComing: "Enemies Incoming...", remaining: "Remaining: ", bossHp: "BOSS HP: ", nextWave: "NEXT WAVE: ", waveComplete: "WAVE COMPLETE!", bossFight: "BOSS FIGHT!", bossMinions: "BOSS + MINIONS!", ulti: "Shock Wave", ready: "READY!", readySimple: "READY", p1: "PLAYER 1", p2: "PLAYER 2", noController: "PRESS ANY BTN", startInfo: "(Starts when both players are ready)", revive: "REVIVE", frozen: "FROZEN!", controllerPS: "PS CONTROLLER", controllerXbox: "XBOX CONTROLLER", langHint: " : CHANGE LANGUAGE", navHint: "(LEFT STICK: Select / A: Confirm)" },
        de: { paused: "PAUSIERT", resume: "FORTSETZEN", menu: "HAUPTMENÜ", restart: "NEUSTART", gameover: "SPIEL VORBEI", totalScore: "GESAMTPUNKTZAHL: ", waveReached: "WELLE ERREICHT: ", pressBtn: "DRÜCK", pressJoin: "BEITRETEN", wave: "WELLE", enemiesComing: "Feinde im Anmarsch...", remaining: "Verbleibend: ", bossHp: "BOSS HP: ", nextWave: "NÄCHSTE WELLE: ", waveComplete: "WELLE ABGESCHLOSSEN!", bossFight: "BOSS-KAMPF!", bossMinions: "BOSS + SCHERGEN!", ulti: "Schockwelle", ready: "BEREIT!", readySimple: "BEREIT", p1: "SPIELER 1", p2: "SPIELER 2", noController: "CONTROLLER WÄHLEN", startInfo: "(Startet, wenn beide Spieler bereit sind)", revive: "RETTEN", frozen: "EINGEFROREN!", controllerPS: "PS CONTROLLER", controllerXbox: "XBOX CONTROLLER", langHint: " : SPRACHE ÄNDERN", navHint: "(LINKER STICK: Wählen / A: Bestätigen)" },
        zh: { paused: "暂停", resume: "继续", menu: "主菜单", restart: "重试", gameover: "游戏结束", totalScore: "总分: ", waveReached: "到达波数: ", pressBtn: "按", pressJoin: "加入", wave: "波", enemiesComing: "敌人来袭...", remaining: "剩余: ", bossHp: "BOSS血量: ", nextWave: "下一波: ", waveComplete: "波数完成!", bossFight: "BOSS战!", bossMinions: "BOSS + 小兵!", ulti: "冲击波", ready: "准备就绪!", readySimple: "准备", p1: "玩家 1", p2: "玩家 2", noController: "按任意键", startInfo: "(当两名玩家准备好时开始)", revive: "复活", frozen: "冻结!", controllerPS: "PS手柄", controllerXbox: "XBOX手柄", langHint: " : 更改语言", navHint: "(左摇杆: 选择 / A: 确认)" }
    };

    let currentLang = 'tr'; 

    function setLanguage(lang) {
        currentLang = lang;
        const t = translations[lang];

        document.querySelectorAll('.lang-btn').forEach(btn => {
            if(btn.dataset.lang === lang) btn.classList.add('active');
            else btn.classList.remove('active');
        });

        document.getElementById('txt-paused').innerText = t.paused;
        document.getElementById('btn-resume').innerText = t.resume;
        document.getElementById('btn-menu-pause').innerText = t.menu;
        document.getElementById('btn-restart').innerText = t.restart;
        document.getElementById('btn-menu-over').innerText = t.menu;

        document.getElementById('txt-gameover').innerText = t.gameover;
        document.getElementById('txt-ulti-1').innerText = t.ulti;
        document.getElementById('txt-ulti-2').innerText = t.ulti;
        document.getElementById('txt-p1-title').innerText = t.p1;
        document.getElementById('txt-p2-title').innerText = t.p2;
        document.getElementById('txt-start-info').innerText = t.startInfo;
        
        document.getElementById('txt-lang-hint').innerText = t.langHint;
        document.getElementById('txt-nav-hint').innerText = t.navHint;
        
        document.querySelectorAll('.txt-press-btn').forEach(el => el.innerText = t.pressJoin);
        document.querySelectorAll('.txt-ready').forEach(el => el.innerText = t.readySimple);

        if (!gameActive) {
            updateControllerUI();
        }
    }

    const ui = {
        p1: { card: document.getElementById('p1-card'), name: document.getElementById('p1-con-name'), startIcon: document.getElementById('p1-start-icon'), ultiIcon: document.getElementById('p1-ulti-icon'), ultiBar: document.getElementById('p1-ulti-bar'), ultiText: document.getElementById('p1-ulti-text'), score: document.getElementById('p1-score') },
        p2: { card: document.getElementById('p2-card'), name: document.getElementById('p2-con-name'), startIcon: document.getElementById('p2-start-icon'), ultiIcon: document.getElementById('p2-ulti-icon'), ultiBar: document.getElementById('p2-ulti-bar'), ultiText: document.getElementById('p2-ulti-text'), score: document.getElementById('p2-score') },
        waveTitle: document.getElementById('wave-title'),
        waveInfo: document.getElementById('wave-info'),
        startScreen: document.getElementById('start-screen'),
        pauseScreen: document.getElementById('pause-screen'),
        gameoverScreen: document.getElementById('gameover-screen'),
        totalScoreDisplay: document.getElementById('total-score-display'),
        finalWaveDisplay: document.getElementById('final-wave-display')
    };

    const P1_COLOR = '#00f7ff';
    const P2_COLOR = '#ffaa00';
    let gameActive = false;
    let isGameOver = false;
    let isPaused = false;
    let shakeTime = 0;
    
    let lastPauseToggle = 0;
    
    // --- KONTROLCÜ VE MENÜ ---
    let p1PadIndex = null;
    let p2PadIndex = null;
    let p1Ready = false;
    let p2Ready = false;
    let buttonStates = {}; 

    // Menu Navigation System
    let menuNavState = {
        lastMove: 0,
        pauseIndex: 0, 
        overIndex: 0, 
        langIndex: 0  
    };
    const langs = ['tr', 'en', 'de', 'zh'];

    let currentWave = 1;
    let waveEnemiesTotal = 0;
    let waveEnemiesKilled = 0;
    let waveEnemiesSpawned = 0;
    let isWaveBreak = false;
    let waveBreakTimer = 0;
    let spawnTimer = 0;
    let spawnRate = 60;
    let isBossWave = false;
    let bossSpawned = false;

    function getControllerType(gamepad) {
        if (!gamepad) return 'xbox';
        const id = gamepad.id.toLowerCase();
        if (id.includes('sony') || id.includes('dual') || id.includes('054c') || id.includes('playstation')) return 'ps';
        return 'xbox';
    }

    function updateIcons(playerId, type) {
        const p = playerId === 0 ? ui.p1 : ui.p2;
        p.startIcon.className = 'btn'; p.startIcon.innerText = ''; 
        p.ultiIcon.className = 'btn'; p.ultiIcon.innerText = ''; 
        p.startIcon.style.border = "2px solid #414040"; 
        p.startIcon.style.color = "";

        if (type === 'ps') {
            p.startIcon.classList.add('ps-cross');
            p.ultiIcon.classList.add('ps-square');
        } else {
            p.startIcon.classList.add('xbox-a'); p.startIcon.innerText = 'A';
            p.ultiIcon.classList.add('xbox-x'); p.ultiIcon.innerText = 'X';
        }
    }

    function updateControllerUI() {
        const pads = navigator.getGamepads ? navigator.getGamepads() : [];
        const t = translations[currentLang];

        if (p1PadIndex !== null && pads[p1PadIndex]) {
            ui.p1.card.classList.add('connected');
            if(p1Ready) ui.p1.card.classList.add('ready'); else ui.p1.card.classList.remove('ready');
            const type = getControllerType(pads[p1PadIndex]);
            ui.p1.name.innerText = (type === 'ps' ? t.controllerPS : t.controllerXbox) + ` [ID:${p1PadIndex}]`;
            ui.p1.name.classList.remove('txt-waiting');
            updateIcons(0, type);
            ui.p1.card.querySelector('.txt-press-btn').innerText = p1Ready ? t.readySimple : t.pressJoin;
        } else {
            ui.p1.card.className = 'player-card'; 
            ui.p1.name.innerText = t.noController;
            ui.p1.name.classList.add('txt-waiting');
            ui.p1.startIcon.className = 'btn'; ui.p1.startIcon.innerText = '?'; ui.p1.startIcon.style.border = "1px dashed #555"; ui.p1.startIcon.style.color = "#555";
        }

        if (p2PadIndex !== null && pads[p2PadIndex]) {
            ui.p2.card.classList.add('connected');
            if(p2Ready) ui.p2.card.classList.add('ready'); else ui.p2.card.classList.remove('ready');
            const type = getControllerType(pads[p2PadIndex]);
            ui.p2.name.innerText = (type === 'ps' ? t.controllerPS : t.controllerXbox) + ` [ID:${p2PadIndex}]`;
            ui.p2.name.classList.remove('txt-waiting');
            updateIcons(1, type);
            ui.p2.card.querySelector('.txt-press-btn').innerText = p2Ready ? t.readySimple : t.pressJoin;
        } else {
            ui.p2.card.className = 'player-card';
            ui.p2.name.innerText = t.noController;
            ui.p2.name.classList.add('txt-waiting');
            ui.p2.startIcon.className = 'btn'; ui.p2.startIcon.innerText = '?'; ui.p2.startIcon.style.border = "1px dashed #555"; ui.p2.startIcon.style.color = "#555";
        }
    }

    function drawPolygon(ctx, x, y, radius, sides, rotation) {
        ctx.beginPath();
        for (let i = 0; i < sides; i++) {
            const angle = rotation + (i * 2 * Math.PI / sides);
            const px = x + radius * Math.cos(angle);
            const py = y + radius * Math.sin(angle);
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
    }

    class Trap {
        constructor(x, y) {
            this.x = x; this.y = y; this.active = true; this.r = 15;
            this.pulse = 0;
        }
        draw() {
            this.pulse += 0.1;
            ctx.save();
            ctx.shadowBlur = 15; ctx.shadowColor = "#ffaa00";
            ctx.strokeStyle = "#ffaa00"; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.stroke();
            
            let coreSize = 5 + Math.sin(this.pulse) * 2;
            ctx.fillStyle = "#ff5500";
            ctx.beginPath(); ctx.arc(this.x, this.y, coreSize, 0, Math.PI*2); ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(this.x - 8, this.y - 8); ctx.lineTo(this.x + 8, this.y + 8);
            ctx.moveTo(this.x + 8, this.y - 8); ctx.lineTo(this.x - 8, this.y + 8);
            ctx.stroke();
            ctx.restore();
        }
    }

    class HealthPack {
        constructor(x, y) {
            this.x = x; this.y = y; this.active = true; this.r = 15;
            this.floatY = 0; this.floatSpeed = 0.05;
        }
        draw() {
            this.floatY += this.floatSpeed;
            let offset = Math.sin(this.floatY) * 5;

            ctx.save();
            ctx.shadowBlur = 20; ctx.shadowColor = "#00ff00";
            ctx.fillStyle = "#00ff00"; 
            ctx.beginPath(); ctx.arc(this.x, this.y + offset, 12, 0, Math.PI*2); ctx.fill();

            ctx.fillStyle = "white"; ctx.shadowBlur = 0;
            ctx.fillRect(this.x - 3, this.y + offset - 8, 6, 16);
            ctx.fillRect(this.x - 8, this.y + offset - 3, 16, 6);
            ctx.restore();
        }
    }

    class Shockwave {
        constructor(x, y, color) {
            this.x=x; this.y=y; this.color=color; this.r=10; this.speed=15; this.active=true; this.lw=10; this.alpha=1;
        }
        update() {
            this.r+=this.speed; this.lw*=0.95; this.alpha-=0.03; if(this.alpha<=0)this.active=false;
            
            for(let i=enemies.length-1; i>=0; i--){
                let e = enemies[i];
                if(Math.abs(Math.hypot(e.x-this.x, e.y-this.y)-this.r)<30){
                    if(e.isBoss) {
                        e.takeDamage(200); 
                    } else {
                        if (e.type === 'shield' && e.shield > 0) {
                            e.takeDamage(200); 
                        } else {
                            createExplosion(e.x,e.y,e.c); enemies.splice(i,1); waveEnemiesKilled++;
                            let owner = players.find(p => p.color === this.color);
                            if(owner) owner.score += 10;
                            if(e.type === 'healer') healthPacks.push(new HealthPack(e.x, e.y));
                        }
                    }
                }
            }
            for(let i=bosses.length-1; i>=0; i--){
                let b = bosses[i];
                if(Math.abs(Math.hypot(b.x-this.x, b.y-this.y)-this.r)<30){
                    b.takeDamage(50);
                }
            }
        }
        draw() {
            ctx.save(); ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2);
            ctx.strokeStyle=this.color; ctx.lineWidth=this.lw; ctx.globalAlpha=this.alpha;
            ctx.shadowBlur=20; ctx.shadowColor=this.color; ctx.stroke(); ctx.restore();
        }
    }

    class Player {
        constructor(id, color) {
            this.id=id; this.color=color; this.reset();
        }
        reset() {
            this.x=canvas.width/2+(this.id===0?-100:100); this.y=canvas.height/2;
            this.r=20; this.speed=6; this.lives=2; this.isDead=false; this.invulnerableTime=0;
            this.reviveProgress=0; this.score=0; this.lastShot=0; this.lastUlti=0;
            this.frozenTime = 0; 
        }
        update(gamepad) {
            if(this.isDead) return;
            if(this.invulnerableTime>0) this.invulnerableTime--;
            
            if (this.frozenTime > 0) {
                this.frozenTime--;
                return; 
            }

            this.x += (Math.abs(gamepad.axes[0])>0.1?gamepad.axes[0]:0)*this.speed;
            this.y += (Math.abs(gamepad.axes[1])>0.1?gamepad.axes[1]:0)*this.speed;
            this.constrain();
            
            let ax=Math.abs(gamepad.axes[2])>0.1?gamepad.axes[2]:0, ay=Math.abs(gamepad.axes[3])>0.1?gamepad.axes[3]:0;
            if(ax!==0||ay!==0){
                this.aimAngle=Math.atan2(ay,ax);
                if(Date.now()-this.lastShot>100){
                    bullets.push(new Bullet(this.x,this.y,this.aimAngle,this.color));
                    
                    AudioEngine.playShoot(); 
                    
                    const padIdx = this.id === 0 ? p1PadIndex : p2PadIndex;
                    
                    // RECOIL (Geri Tepme) Hesabı
                    let aimX = Math.cos(this.aimAngle);
                    let strong = 0.4; 
                    let weak = 0.4;
                    if (aimX > 0) { strong += aimX * 0.4; weak -= aimX * 0.2; } 
                    else { weak += Math.abs(aimX) * 0.4; strong -= Math.abs(aimX) * 0.2; }

                    rumble(padIdx, 80, weak, strong); 

                    this.lastShot=Date.now(); this.x-=Math.cos(this.aimAngle)*2; this.y-=Math.sin(this.aimAngle)*2;
                }
            }
            if(gamepad.buttons[2].pressed) this.triggerUlti();
            this.updateUI();
        }
        triggerUlti() {
            if(Date.now()-this.lastUlti>20000) {
                this.lastUlti=Date.now(); 
                shockwaves.push(new Shockwave(this.x,this.y,this.color));
                AudioEngine.playUlti(); 
                shakeTime=30;
                const padIdx = this.id === 0 ? p1PadIndex : p2PadIndex;
                rumble(padIdx, 600, 0.8, 1.0); 
            }
        }
        updateUI() {
            let passed=Date.now()-this.lastUlti, pct=Math.min((passed/20000)*100,100);
            if(this.lastUlti===0) pct=100;
            const u = this.id===0?ui.p1:ui.p2;
            u.ultiBar.style.width=pct+"%";
            
            const t = translations[currentLang];
            if(pct>=100){ u.ultiBar.style.backgroundColor=this.color; u.ultiBar.style.boxShadow=`0 0 10px ${this.color}`; u.ultiText.innerText=t.ready; u.ultiText.style.opacity=1; } 
            else { u.ultiBar.style.backgroundColor="#555"; u.ultiBar.style.boxShadow="none"; u.ultiText.innerText=Math.ceil((20000-passed)/1000)+"s"; u.ultiText.style.opacity=0.5; }
        }
        constrain() { if(this.x<this.r)this.x=this.r; if(this.x>canvas.width-this.r)this.x=canvas.width-this.r; if(this.y<this.r)this.y=this.r; if(this.y>canvas.height-this.r)this.y=canvas.height-this.r; }
        
        takeDamage(amount = 1) {
            if(this.invulnerableTime>0||this.isDead) return;
            this.lives -= amount; shakeTime=15;

            const padIdx = this.id === 0 ? p1PadIndex : p2PadIndex;
            rumble(padIdx, 300, 0.8, 1.0);

            if(this.lives<=0) { this.isDead=true; this.lives=0; createExplosion(this.x,this.y,this.color); }
            else { this.invulnerableTime=120; createExplosion(this.x,this.y,"#fff"); }
        }
        heal() {
            this.lives = 2; 
            createExplosion(this.x, this.y, "#00ff00");
        }
        freeze() {
            this.frozenTime = 120; 
            shakeTime = 5;
            const padIdx = this.id === 0 ? p1PadIndex : p2PadIndex;
            rumble(padIdx, 200, 0.5, 0.5);
        }
        draw() {
            if(this.isDead){
                ctx.save(); ctx.globalAlpha=0.3; ctx.strokeStyle=this.color; ctx.lineWidth=2;
                ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.stroke();
                
                ctx.font="12px Orbitron"; ctx.fillStyle="white"; ctx.textAlign="center"; 
                ctx.fillText(translations[currentLang].revive, this.x,this.y-35);
                
                if(this.reviveProgress>0){ctx.fillStyle="#00ff00";ctx.fillRect(this.x-20,this.y+35,(this.reviveProgress/100)*40,5);}
                ctx.restore(); return;
            }
            if(this.invulnerableTime>0 && Math.floor(Date.now()/50)%2===0)return;
            
            ctx.save(); 
            ctx.shadowBlur=15; ctx.shadowColor=this.color; ctx.fillStyle=this.color;
            
            if (this.frozenTime > 0) {
                ctx.shadowColor = "#00ffff"; ctx.fillStyle = "#88ffff"; 
                ctx.font = "bold 14px Arial"; ctx.fillText(translations[currentLang].frozen, this.x-25, this.y+40);
            }

            ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill();
            ctx.shadowBlur=0; ctx.strokeStyle="rgba(255,255,255,0.5)"; ctx.lineWidth=2;
            ctx.beginPath(); ctx.moveTo(this.x,this.y); ctx.lineTo(this.x+Math.cos(this.aimAngle)*40,this.y+Math.sin(this.aimAngle)*40); ctx.stroke();
            ctx.font="14px Arial"; ctx.fillStyle="#ff3333"; ctx.textAlign="center";
            let h=""; for(let i=0;i<this.lives;i++)h+="❤"; ctx.fillText(h,this.x,this.y-30);
            ctx.fillStyle="#000"; ctx.font="bold 10px Orbitron"; ctx.textBaseline="middle"; ctx.fillText(this.id===0?"P1":"P2",this.x,this.y); ctx.restore();
        }
    }

    class Bullet {
        constructor(x,y,a,c){this.x=x+Math.cos(a)*20;this.y=y+Math.sin(a)*20;this.vx=Math.cos(a)*15;this.vy=Math.sin(a)*15;this.c=c;}
        update(){this.x+=this.vx;this.y+=this.vy;}
        draw(){ctx.save();ctx.shadowBlur=10;ctx.shadowColor=this.c;ctx.fillStyle="white";ctx.beginPath();ctx.arc(this.x,this.y,4,0,Math.PI*2);ctx.fill();ctx.restore();}
    }
    
    class Enemy {
        constructor(wave, type = 'normal'){
            let sb=(wave-1)*0.15;
            if(Math.random()<0.5){this.x=Math.random()<0.5?-30:canvas.width+30;this.y=Math.random()*canvas.height;}
            else{this.x=Math.random()*canvas.width;this.y=Math.random()<0.5?-30:canvas.height+30;}
            this.r=15; this.s=(Math.random()*2+1)+sb; 
            this.isBoss = false;
            this.type = type; 
            
            this.angle = 0; 
            this.spinSpeed = 0.05;

            if (this.type === 'normal') { this.c = '#ff0044'; this.spinSpeed = 0.1; } 
            else if (this.type === 'healer') { this.c = '#00ff00'; this.s *= 0.8; this.spinSpeed = 0.02; } 
            else if (this.type === 'shield') { this.c = '#0088ff'; this.shield = 50; this.s *= 0.9; this.spinSpeed = 0.01; } 
            else if (this.type === 'trapper') { this.c = '#ffaa00'; this.trapTimer = 0; this.spinSpeed = 0; } 
        }
        update(){
            let t=null, d1=players[0].isDead?Infinity:Math.hypot(players[0].x-this.x,players[0].y-this.y), d2=players[1].isDead?Infinity:Math.hypot(players[1].x-this.x,players[1].y-this.y);
            if(d1===Infinity&&d2===Infinity)return;
            t=d1<d2?players[0]:players[1];
            let a=Math.atan2(t.y-this.y,t.x-this.x); this.x+=Math.cos(a)*this.s; this.y+=Math.sin(a)*this.s;

            this.angle += this.spinSpeed; 

            if (this.type === 'trapper') {
                this.trapTimer++;
                if (this.trapTimer > 180) { 
                    traps.push(new Trap(this.x, this.y));
                    this.trapTimer = 0;
                }
            }
        }
        takeDamage(amount) {
            if (this.type === 'shield') {
                if (this.shield > 0) {
                    this.shield -= amount;
                    createExplosion(this.x, this.y, '#0088ff'); 
                    return false; 
                }
            }
            return true; 
        }
        draw(){
            ctx.save(); 
            ctx.translate(this.x, this.y); 
            
            ctx.shadowBlur=15; ctx.shadowColor=this.c;
            ctx.strokeStyle=this.c; 
            ctx.lineWidth=2;

            if (this.type === 'normal') {
                ctx.rotate(this.angle);
                ctx.fillStyle = this.c;
                ctx.beginPath();
                ctx.rect(-10, -10, 20, 20); 
                ctx.fill();
                ctx.shadowBlur=0; ctx.fillStyle = "rgba(255,255,255,0.5)";
                ctx.beginPath(); ctx.arc(0,0,5,0,Math.PI*2); ctx.fill();
            } 
            else if (this.type === 'healer') {
                ctx.rotate(this.angle);
                ctx.fillStyle = this.c;
                ctx.fillRect(-15, -5, 30, 10);
                ctx.fillRect(-5, -15, 10, 30);
                ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2); ctx.stroke();
            }
            else if (this.type === 'shield') {
                ctx.rotate(this.angle);
                ctx.fillStyle = this.c;
                drawPolygon(ctx, 0, 0, 15, 6, 0); 
                ctx.fill();
                if (this.shield > 0) {
                    ctx.rotate(-this.angle * 2); 
                    ctx.shadowColor = "#00ffff"; ctx.strokeStyle = "#00ffff"; ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.arc(0, 0, 22, 0, Math.PI*1.5); 
                    ctx.stroke();
                }
            }
            else if (this.type === 'trapper') {
                let blink = Math.abs(Math.sin(Date.now() / 200));
                ctx.globalAlpha = 0.5 + blink * 0.5;
                ctx.fillStyle = this.c;
                drawPolygon(ctx, 0, 0, 18, 3, -Math.PI/2); 
                ctx.fill();
                ctx.fillStyle = "white"; ctx.globalAlpha = 1;
                ctx.beginPath(); ctx.arc(0, 2, 4, 0, Math.PI*2); ctx.fill();
            }

            ctx.restore();
        }
    }

    class Boss {
        constructor(wave) {
            this.x = canvas.width/2; this.y = -100;
            this.r = 60; this.s = 1.5 + (wave * 0.1); 
            this.c = '#bf00ff'; 
            this.hp = 150 * wave; 
            this.maxHp = this.hp;
            this.isBoss = true;
            this.angle = 0;
        }
        update() {
            let t=null, d1=players[0].isDead?Infinity:Math.hypot(players[0].x-this.x,players[0].y-this.y), d2=players[1].isDead?Infinity:Math.hypot(players[1].x-this.x,players[1].y-this.y);
            if(d1===Infinity&&d2===Infinity)return;
            t=d1<d2?players[0]:players[1];
            let a=Math.atan2(t.y-this.y,t.x-this.x); this.x+=Math.cos(a)*this.s; this.y+=Math.sin(a)*this.s;
            this.angle += 0.02;
        }
        takeDamage(amount) {
            this.hp-=amount;
            if(this.hp<=0) { createExplosion(this.x,this.y,this.c); waveEnemiesKilled++; }
        }
        draw() {
            ctx.save(); 
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);

            ctx.shadowBlur=40; ctx.shadowColor=this.c; ctx.strokeStyle=this.c; ctx.lineWidth=4;
            
            ctx.strokeRect(-40, -40, 80, 80);
            ctx.rotate(Math.PI/4);
            ctx.strokeRect(-40, -40, 80, 80);
            
            ctx.rotate(-this.angle * 2); 
            ctx.fillStyle = "black";
            ctx.beginPath(); ctx.arc(0,0,30,0,Math.PI*2); ctx.fill();
            ctx.fillStyle = this.c;
            ctx.beginPath(); ctx.arc(0,0,15 + Math.sin(Date.now()/100)*5,0,Math.PI*2); ctx.fill();

            ctx.restore();

            ctx.save();
            ctx.fillStyle = "black"; ctx.fillRect(this.x-50, this.y-80, 100, 10);
            ctx.fillStyle = "red"; ctx.fillRect(this.x-50, this.y-80, 100*(this.hp/this.maxHp), 10);
            ctx.strokeStyle = "white"; ctx.strokeRect(this.x-50, this.y-80, 100, 10);
            ctx.fillStyle="white"; ctx.font="bold 14px Orbitron"; ctx.textAlign="center"; ctx.fillText("BOSS",this.x,this.y-90); 
            ctx.restore();
        }
    }

    class Particle{constructor(x,y,c){this.x=x;this.y=y;this.vx=(Math.random()-0.5)*10;this.vy=(Math.random()-0.5)*10;this.life=1;this.c=c;}update(){this.x+=this.vx;this.y+=this.vy;this.life-=0.04;}draw(){ctx.save();ctx.globalAlpha=this.life;ctx.fillStyle=this.c;ctx.beginPath();ctx.arc(this.x,this.y,3,0,Math.PI*2);ctx.fill();ctx.restore();}}

    const players=[new Player(0,P1_COLOR),new Player(1,P2_COLOR)];
    let bullets=[], enemies=[], particles=[], shockwaves=[], bosses=[], traps=[], healthPacks=[];

    function createExplosion(x,y,c){
        AudioEngine.playExplosion();
        for(let i=0;i<15;i++)particles.push(new Particle(x,y,c));
    }

    function startWave(waveNum) {
        currentWave = waveNum; isWaveBreak = false;
        traps = []; healthPacks = []; 
        
        const t = translations[currentLang]; 

        if (waveNum % 5 === 0) { 
            isBossWave = true; bossSpawned = false;
            let minions = 5 + (waveNum * 2); 
            waveEnemiesTotal = 1 + minions;
            waveEnemiesKilled = 0; waveEnemiesSpawned = 0;
            spawnRate = 40; 
            ui.waveTitle.innerText = t.bossFight; ui.waveTitle.classList.add("boss-warning");
            ui.waveInfo.className = "wave-info"; ui.waveInfo.innerText = t.bossMinions;
            
            if (p1PadIndex !== null) rumble(p1PadIndex, 800, 0.5, 0.5);
            if (p2PadIndex !== null) rumble(p2PadIndex, 800, 0.5, 0.5);
        } else {
            isBossWave = false;
            waveEnemiesTotal = 5 + (waveNum * 3); 
            waveEnemiesKilled = 0; waveEnemiesSpawned = 0;
            spawnRate = Math.max(10, 60 - (waveNum * 2));
            ui.waveTitle.innerText = t.wave + " " + waveNum; ui.waveTitle.classList.remove("boss-warning");
            ui.waveInfo.className = "wave-info"; ui.waveInfo.innerText = t.remaining + waveEnemiesTotal;
        }
    }

    function startWaveBreak() {
        const t = translations[currentLang];
        isWaveBreak=true; waveBreakTimer=20; 
        ui.waveTitle.innerText=t.waveComplete; ui.waveTitle.classList.remove("boss-warning");
        ui.waveInfo.className="wave-break";
    }

    // --- MENÜ KONTROLLERİ ---
    function updateMenuFocus() {
        AudioEngine.playMenuMove();
        // Pause Menüsü
        const pauseBtns = document.getElementById('pause-menu').children;
        Array.from(pauseBtns).forEach((b, i) => {
            if (i === menuNavState.pauseIndex) b.classList.add('selected'); else b.classList.remove('selected');
        });

        // Game Over Menüsü
        const overBtns = document.getElementById('gameover-menu').children;
        Array.from(overBtns).forEach((b, i) => {
            if (i === menuNavState.overIndex) b.classList.add('selected'); else b.classList.remove('selected');
        });
    }

    function resetMenuState() {
        menuNavState.pauseIndex = 0;
        menuNavState.overIndex = 0;
        updateMenuFocus();
    }

    function togglePause() { 
        isPaused=!isPaused; 
        ui.pauseScreen.style.display=isPaused?'flex':'none'; 
        if(isPaused) resetMenuState();
    }

    function restartGame() {
        isGameOver = false; isPaused = false;
        ui.gameoverScreen.style.display = 'none';
        bullets=[]; enemies=[]; particles=[]; shockwaves=[]; bosses=[]; traps=[]; healthPacks=[];
        players[0].reset(); players[1].reset();
        players[0].score = 0; players[1].score = 0;
        currentWave = 1;
        AudioEngine.playMenuSelect();
        startWave(1);
    }

    function resetToMenu() {
        gameActive = false; isGameOver = false; isPaused = false;
        p1Ready = false; p2Ready = false;
        ui.p1.card.classList.remove('ready'); ui.p2.card.classList.remove('ready');
        ui.gameoverScreen.style.display = 'none';
        ui.pauseScreen.style.display = 'none';
        ui.startScreen.style.display = 'flex';
        bullets=[]; enemies=[]; particles=[]; shockwaves=[]; bosses=[]; traps=[]; healthPacks=[];
        players[0].reset(); players[1].reset();
        currentWave = 1;
        updateControllerUI();
    }

    function handleMenuInputs(pads) {
        let inputDirection = { up: false, down: false, lb: false, rb: false, select: false };
        let anyButton = false;
        
        for (let i = 0; i < pads.length; i++) {
            const pad = pads[i];
            if (!pad) continue;
            
            if (pad.buttons.some(b => b.pressed) || Math.abs(pad.axes[0]) > 0.1 || Math.abs(pad.axes[1]) > 0.1) {
                anyButton = true;
            }

            if (pad.axes[1] < -0.5) inputDirection.up = true;
            if (pad.axes[1] > 0.5) inputDirection.down = true;
            if (pad.buttons[4].pressed) inputDirection.lb = true;
            if (pad.buttons[5].pressed) inputDirection.rb = true;
            if (pad.buttons[0].pressed) inputDirection.select = true; 
        }

        // SES MOTORUNU BAŞLAT
        if(anyButton && !AudioEngine.initialized) {
            AudioEngine.init();
        }

        const now = Date.now();
        if (now - menuNavState.lastMove > 200) {
            
            // 1. DİL SEÇİMİ (START EKRANI)
            if (!gameActive && ui.startScreen.style.display !== 'none') {
                if (inputDirection.rb) {
                    menuNavState.langIndex = (menuNavState.langIndex + 1) % langs.length;
                    setLanguage(langs[menuNavState.langIndex]);
                    AudioEngine.playMenuMove();
                    menuNavState.lastMove = now;
                }
                if (inputDirection.lb) {
                    menuNavState.langIndex = (menuNavState.langIndex - 1 + langs.length) % langs.length;
                    setLanguage(langs[menuNavState.langIndex]);
                    AudioEngine.playMenuMove();
                    menuNavState.lastMove = now;
                }
            }

            // 2. PAUSE MENÜSÜ
            if (isPaused) {
                if (inputDirection.down) { menuNavState.pauseIndex = 1; updateMenuFocus(); menuNavState.lastMove = now; }
                if (inputDirection.up) { menuNavState.pauseIndex = 0; updateMenuFocus(); menuNavState.lastMove = now; }
                
                if (inputDirection.select) {
                    AudioEngine.playMenuSelect();
                    if (menuNavState.pauseIndex === 0) togglePause(); 
                    else resetToMenu(); 
                    menuNavState.lastMove = now + 200; 
                }
            }

            // 3. GAME OVER MENÜSÜ
            if (isGameOver) {
                if (inputDirection.down) { menuNavState.overIndex = 1; updateMenuFocus(); menuNavState.lastMove = now; }
                if (inputDirection.up) { menuNavState.overIndex = 0; updateMenuFocus(); menuNavState.lastMove = now; }

                if (inputDirection.select) {
                    AudioEngine.playMenuSelect();
                    if (menuNavState.overIndex === 0) restartGame(); 
                    else resetToMenu(); 
                    menuNavState.lastMove = now + 500;
                }
            }
        }

        // KOL SEÇİM MANTIĞI (Sadece oyun başlamadan önce)
        if (!gameActive) {
            for (let i = 0; i < pads.length; i++) {
                const pad = pads[i];
                if (!pad) continue;
                if (!buttonStates[i]) buttonStates[i] = { pressed: false };
                const anyBtn = pad.buttons.some(b => b.pressed);

                if (anyBtn && !buttonStates[i].pressed) {
                    buttonStates[i].pressed = true;
                    const isP1 = (p1PadIndex === i);
                    const isP2 = (p2PadIndex === i);

                    if (pad.buttons[0].pressed) {
                        AudioEngine.playMenuSelect();
                        if (!isP1 && !isP2) {
                            if (p1PadIndex === null) { p1PadIndex = i; rumble(i, 200, 0.5, 0.0); }
                            else if (p2PadIndex === null) { p2PadIndex = i; rumble(i, 200, 0.5, 0.0); }
                        } else {
                            if (isP1) { p1Ready = !p1Ready; rumble(i, 100, 0.2, 0.0); }
                            if (isP2) { p2Ready = !p2Ready; rumble(i, 100, 0.2, 0.0); }
                        }
                    }
                    if (pad.buttons[1].pressed) {
                        if (isP1) { if (p1Ready) p1Ready = false; else p1PadIndex = null; }
                        if (isP2) { if (p2Ready) p2Ready = false; else p2PadIndex = null; }
                    }
                    updateControllerUI();
                }
                if (!anyBtn) buttonStates[i].pressed = false;
            }

            let p1OK = (p1PadIndex !== null && p1Ready);
            let p2OK = (p2PadIndex !== null && p2Ready);
            let p1Exist = p1PadIndex !== null;
            let p2Exist = p2PadIndex !== null;
            let allReady = false;
            if (p1Exist && p2Exist) allReady = p1OK && p2OK;
            else if (p1Exist) allReady = p1OK;
            else if (p2Exist) allReady = p2OK;

            if(allReady && (p1Exist || p2Exist)) { 
                gameActive=true; 
                ui.startScreen.style.display='none'; 
                startWave(1); 
            }
        }
    }

    function updateGameLogic(pads) {
        if(isPaused || isGameOver) return;

        // Start/Pause Kontrolü (Oyun içindeyken)
        let p1Start = p1PadIndex !== null && pads[p1PadIndex] && pads[p1PadIndex].buttons[9].pressed;
        let p2Start = p2PadIndex !== null && pads[p2PadIndex] && pads[p2PadIndex].buttons[9].pressed;

        if((p1Start || p2Start) && Date.now()-lastPauseToggle>300) { 
            if(!isGameOver) { togglePause(); lastPauseToggle=Date.now(); }
        }

        // Shake efektini mantık döngüsünde azaltıyoruz
        if(shakeTime>0) shakeTime--;

        if(p1PadIndex !== null && pads[p1PadIndex]) players[0].update(pads[p1PadIndex]);
        if(p2PadIndex !== null && pads[p2PadIndex]) players[1].update(pads[p2PadIndex]);

        const t = translations[currentLang];

        if(!isWaveBreak) {
            if (waveEnemiesSpawned < waveEnemiesTotal) {
                spawnTimer++;
                if(spawnTimer > spawnRate) {
                    if (isBossWave && !bossSpawned) { bosses.push(new Boss(currentWave)); bossSpawned = true; }
                    else {
                        let type = 'normal';
                        if (currentWave >= 2 && Math.random() < 0.1) type = 'healer';
                        else if (currentWave % 2 === 0 && Math.random() < 0.2) type = 'trapper';
                        else if (currentWave >= 3 && Math.random() < 0.15) type = 'shield';
                        enemies.push(new Enemy(currentWave, type)); 
                        waveEnemiesSpawned++;
                    }
                    spawnTimer = 0;
                }
            } else if (enemies.length === 0 && (!isBossWave || bosses.length === 0)) {
                startWaveBreak();
            }
            
            if(isBossWave && bosses.length > 0) ui.waveInfo.innerText = t.bossHp + Math.floor(bosses[0].hp);
            else ui.waveInfo.innerText = t.remaining + (waveEnemiesTotal - waveEnemiesKilled);
        } else {
            if(spawnTimer%60===0) { // Buradaki 60 mantığı fixed stepte sabit olduğu için artık saniye şaşmaz
                waveBreakTimer--; ui.waveInfo.innerText=t.nextWave + waveBreakTimer + "s";
                if(waveBreakTimer<=0) startWave(currentWave+1);
            }
            spawnTimer++;
        }

        [0,1].forEach(i=>{
            let me=players[i], other=players[i===0?1:0];
            if ((i===0 && p1PadIndex===null) || (i===1 && p2PadIndex===null)) return;

            if(me.isDead && !other.isDead && Math.hypot(me.x-other.x,me.y-other.y)<60) {
                me.reviveProgress+=1.5;
                if(me.reviveProgress>=100) { 
                    me.isDead=false; me.lives=2; me.reviveProgress=0; me.invulnerableTime=180; 
                    createExplosion(me.x,me.y,'#00ff00'); shakeTime=20; 
                    rumble(i===0?p1PadIndex:p2PadIndex, 400, 0.5, 0.5);
                }
            } else me.reviveProgress=0;
        });

        shockwaves.forEach((s,i)=>{if(s.active){s.update();}else shockwaves.splice(i,1);});
        
        for(let i=bosses.length-1; i>=0; i--){
            let b = bosses[i];
            if(b.hp > 0) {
                b.update();
                players.forEach(p => { 
                    if((p.id===0 && p1PadIndex===null) || (p.id===1 && p2PadIndex===null)) return;
                    if(!p.isDead && p.invulnerableTime<=0 && Math.hypot(p.x-b.x, p.y-b.y) < p.r + b.r) { 
                        p.takeDamage(2); shakeTime=20; 
                    } 
                });
            } else bosses.splice(i, 1);
        }

        for(let i=bullets.length-1;i>=0;i--){
            let b=bullets[i]; b.update();
            if(b.x<0||b.x>canvas.width||b.y<0||b.y>canvas.height){bullets.splice(i,1);continue;}
            
            let hit = false;
            for(let j=enemies.length-1;j>=0;j--){
                let e=enemies[j];
                if(Math.hypot(b.x-e.x,b.y-e.y)<e.r+4){
                    let died = e.takeDamage(10); 
                    if (died) {
                        createExplosion(e.x,e.y,e.c); enemies.splice(j,1); waveEnemiesKilled++;
                        if(b.c===P1_COLOR)players[0].score+=10;else players[1].score+=10;
                        if(e.type==='healer') healthPacks.push(new HealthPack(e.x, e.y));
                    }
                    bullets.splice(i,1); hit = true; break;
                }
            }
            if(hit) continue;

            for(let k=bosses.length-1; k>=0; k--){
                let boss = bosses[k];
                if(Math.hypot(b.x-boss.x, b.y-boss.y) < boss.r + 4) {
                    boss.takeDamage(5); createExplosion(b.x, b.y, "#fff");
                    bullets.splice(i, 1);
                    if(b.c===P1_COLOR)players[0].score+=2;else players[1].score+=2;
                    break;
                }
            }
        }
        
        for(let i=enemies.length-1;i>=0;i--){
            let e=enemies[i]; e.update();
            for(let j=0; j<players.length; j++){
                let p = players[j];
                if((p.id===0 && p1PadIndex===null) || (p.id===1 && p2PadIndex===null)) continue;

                if(!p.isDead && p.invulnerableTime<=0 && Math.hypot(p.x-e.x,p.y-e.y)<p.r+e.r){
                    p.takeDamage(1); createExplosion(e.x,e.y,e.c); enemies.splice(i,1); waveEnemiesKilled++; break;
                }
            }
        }

        for(let i=traps.length-1; i>=0; i--) {
            let t = traps[i]; 
            players.forEach(p => {
                if((p.id===0 && p1PadIndex===null) || (p.id===1 && p2PadIndex===null)) return;
                if (!p.isDead && Math.hypot(p.x-t.x, p.y-t.y) < t.r + p.r) {
                    p.freeze(); traps.splice(i, 1);
                }
            });
        }
        for(let i=healthPacks.length-1; i>=0; i--) {
            let h = healthPacks[i]; 
            players.forEach(p => {
                if((p.id===0 && p1PadIndex===null) || (p.id===1 && p2PadIndex===null)) return;
                if (!p.isDead && Math.hypot(p.x-h.x, p.y-h.y) < h.r + p.r) {
                    p.heal(); healthPacks.splice(i, 1);
                }
            });
        }
        
        particles.forEach((p,i)=>{p.update(); if(p.life<=0)particles.splice(i,1);});
        
        // Oyun Bitti Kontrolü
        let activePlayersCount = (p1PadIndex !== null ? 1 : 0) + (p2PadIndex !== null ? 1 : 0);
        let deadPlayersCount = (p1PadIndex !== null && players[0].isDead ? 1 : 0) + (p2PadIndex !== null && players[1].isDead ? 1 : 0);
        
        if(activePlayersCount > 0 && activePlayersCount === deadPlayersCount) isGameOver=true;
    }

    function drawGame() {
        if(isPaused || isGameOver) {
            if(isGameOver && ui.gameoverScreen.style.display !== 'flex') {
                 const t = translations[currentLang];
                 ui.gameoverScreen.style.display='flex';
                 ui.finalWaveDisplay.innerText = t.waveReached + currentWave;
                 ui.totalScoreDisplay.innerText = t.totalScore + (players[0].score + players[1].score);
                 resetMenuState();
            }
            return; 
        }

        ctx.fillStyle = "#050505"; ctx.fillRect(0,0,canvas.width, canvas.height);
        
        if(shakeTime>0) { 
            ctx.save(); 
            ctx.translate((Math.random()-0.5)*15,(Math.random()-0.5)*15); 
        }

        ctx.strokeStyle="#111"; ctx.lineWidth=2; ctx.beginPath();
        for(let x=0;x<canvas.width;x+=50){ctx.moveTo(x,0);ctx.lineTo(x,canvas.height);}
        for(let y=0;y<canvas.height;y+=50){ctx.moveTo(0,y);ctx.lineTo(canvas.width,y);} ctx.stroke();

        shockwaves.forEach(s => s.draw());
        traps.forEach(t => t.draw());
        healthPacks.forEach(h => h.draw());
        bosses.forEach(b => b.draw());
        
        if(p1PadIndex !== null) players[0].draw(); 
        if(p2PadIndex !== null) players[1].draw();
        
        bullets.forEach(b => b.draw());
        enemies.forEach(e => e.draw());
        particles.forEach(p => p.draw());

        if(shakeTime>0) ctx.restore();

        ui.p1.score.innerText = `P1: ${players[0].score}`; 
        ui.p2.score.innerText = `P2: ${players[1].score}`;
    }

    // --- YENİ OYUN DÖNGÜSÜ (FIXED TIMESTEP) ---
    function loop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        let deltaTime = timestamp - lastTime;
        lastTime = timestamp;
        
        // Çok büyük takılmalarda sonsuz döngüyü önlemek için limit
        if (deltaTime > 100) deltaTime = 100;

        accumulator += deltaTime;

        // Kontrolcüleri her karede oku
        const pads = navigator.getGamepads ? navigator.getGamepads() : [];
        handleMenuInputs(pads);

        // Biriken zamanı (accumulator) sabit adımlarla (TIME_STEP) tüket
        // Bu sayede ekran 60hz de olsa mantık 144hz (TIME_STEP) hızında çalışır
        while (accumulator >= TIME_STEP) {
            updateGameLogic(pads);
            accumulator -= TIME_STEP;
        }
        
        drawGame();
        requestAnimationFrame(loop);
    }
    
    // Döngüyü başlat
    requestAnimationFrame(loop);

    window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
</script>
</body>
</html>
